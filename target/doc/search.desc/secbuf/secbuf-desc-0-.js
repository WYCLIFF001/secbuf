searchState.loadedDescShard("secbuf", 0, "High-Performance Buffer Library\nHigh-performance buffer implementation\nConvenience macro for converting buffer operations to any …\nTry a buffer operation with automatic error conversion\nCircular (ring) buffer for streaming data\nConnection-scoped buffer lifecycle with aggressive cleanup\nError types for buffer operations with advanced conversion …\nBuffer pool implementation with multiple modes.\nCommonly used imports.\nCore buffer structure with aggressive memory management\nBuffer read/write operations\nUnchecked (unsafe) buffer operations for maximum …\nMaximum single increment to prevent integer overflow\nMaximum buffer size (1GB)\nA high-performance linear buffer with aggressive memory …\nAggressive shrink: zeros everything and shrinks to minimal …\nReturns a mutable slice of all valid data.\nReturns a slice of all valid data in the buffer.\nSecurely zeros all buffer memory and resets position and …\nAggressive cleanup: zeros memory AND shrinks capacity to …\nConsumes the buffer and securely frees its memory.\nReturns the total capacity of the buffer.\nResets position and length to zero without zeroing memory.\nCreates an explicit, unsecure clone of this buffer.\nInternal data storage (securely erased on drop)\nSkips over an SSH-style string without reading the data.\nReturns the argument unchanged.\nCreates a new buffer from existing data.\nReads a boolean (0 = false, non-zero = true).\nReads a single byte.\nReads bytes, returning an owned <code>Vec</code>.\nReads bytes as a slice reference (zero-copy).\nReads bytes without bounds checking, returning a slice.\nGets a reference to data at current position without …\nReads an SSH-style string (4-byte length prefix + data).\nReads a <code>u32</code> in big-endian format with bounds checking.\nReads a <code>u32</code> in big-endian format without bounds checking.\nReads a <code>u64</code> in big-endian format with bounds checking.\nReads a <code>u64</code> in big-endian format without bounds checking.\nGets a mutable reference to data at current position (for …\nChecks if at least <code>count</code> bytes are available to read.\nIncrements the length by <code>n</code> bytes.\nIncrements the position by <code>n</code> bytes.\nIncrements the write position (alias for <code>incr_len</code>).\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the buffer contains no valid data.\nChecks if buffer capacity is wasteful compared to usage.\nReturns the length of valid data in the buffer.\nLength of valid data\nReturns memory overhead in bytes (capacity - length).\nCreates a new buffer with zeroed memory.\nReturns the current read/write position.\nCurrent read/write position\nWrites a single byte.\nWrites bytes with a single bounds check.\nAVX2 implementation for fast bulk copy.\nSIMD-accelerated bulk copy for large buffers (≥64 bytes).\nWrites bytes without bounds checking.\nWrites an SSH-style string (4-byte length prefix + data).\nWrites a <code>u32</code> in big-endian format with bounds checking.\nWrites a <code>u32</code> in big-endian format without bounds checking.\nWrites a <code>u64</code> in big-endian format with bounds checking.\nWrites a <code>u64</code> in big-endian format without bounds checking.\nReturns the number of bytes available to read from current …\nEnsures the buffer has at least the specified additional …\nResets position and length to zero without zeroing memory.\nResets and aggressively shrinks if capacity is much larger …\nResizes the buffer, preserving existing data.\nSets the length of valid data.\nSets the read/write position.\nShrinks the buffer capacity to fit the current length.\nCreates a new buffer with zeroed memory.\nCreates a new buffer with pre-allocated capacity but zero …\nCreates a new buffer with pre-allocated capacity.\nMaximum pointer/slice length to prevent accidental huge …\nMaximum SSH-style string length (400KB - reasonable for …\nCircular buffer with aggressive cleanup and memory safety\nCircular buffer with aggressive memory management.\nMemory statistics for a circular buffer.\nMaximum circular buffer size (100MB)\nWhether buffer memory is allocated\nReturns the number of bytes available for writing.\nConsumes and securely frees the buffer.\nClears the buffer <strong>without</strong> freeing memory.\nClears and optionally frees memory if buffer is idle.\nInternal storage (lazily allocated, auto-zeroized on drop)\nSecurely zeros and frees memory.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIncrements the read position, discarding data.\nIncrements the write position after using <code>write_ptr</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if buffer memory has been allocated.\nReturns <code>true</code> if the buffer contains no data.\nReturns <code>true</code> if the buffer is full (no space for writing).\nReturns <code>true</code> if buffer was allocated but is now empty.\nWhether size is power-of-2 (enables fast modulo)\nReturns memory usage statistics.\nCreates a new circular buffer with lazy allocation.\nCreates a new power-of-2 sized circular buffer.\nReads data without removing it (peek operation).\nReads data from the buffer, removing it.\nRead position\nReturns read pointers for zero-copy reading.\nReturns the total capacity of the buffer.\nTotal size of the buffer\nTotal size of buffer\nCreates a new circular buffer with lazy allocation.\nCreates a new power-of-2 sized circular buffer for fast …\nReturns the number of bytes currently stored in the buffer.\nNumber of bytes currently in buffer\nBytes currently in use\nTrack if buffer has ever been allocated (for memory …\nBytes allocated but unused (wasted)\nWrites data to the buffer.\nWrite position\nReturns a mutable slice for zero-copy writing.\nAggressively zeros all data without freeing allocation.\nDiagnostic information for a single buffer.\nConfiguration for connection buffer limits.\nA connection’s buffer state with aggressive memory …\nConnection-level diagnostics for debugging.\nMemory usage statistics for a connection.\nPooled connection buffers with automatic cleanup on drop.\nError returned when packet queue reaches capacity.\nQueue has reached maximum byte limit\nQueue has reached maximum packet count\nAdds a new circular buffer for streaming data.\nAggressive cleanup: zeros and frees all memory.\nReturns a mutable reference to the underlying connection …\nInternal connection buffers\nSecurely zeros all sensitive data.\nTotal allocated capacity\nCleanup counter for periodic operations\nNumber of periodic cleanup operations performed\nConfiguration\nDequeues the next packet from the queue.\nReturns detailed diagnostics for debugging memory issues.\nAutomatically performs aggressive cleanup when dropped.\nReturns memory efficiency ratio (0.0 to 1.0).\nEnable aggressive memory shrinking\nForce aggressive shrinking regardless of idle state.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the duration since last activity.\nSeconds since last activity\nIdle timeout before aggressive cleanup (seconds)\nInitializes the read buffer with the specified size.\nInitializes the write buffer with the specified size.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if connection has been idle beyond the …\nWhether connection is idle\nReturns <code>true</code> if memory usage indicates a problem.\nReturns <code>true</code> if the packet queue is near capacity (&gt;80% …\nWhether buffer is considered wasteful\nLast activity timestamp\nBytes of valid data\nMaximum total bytes in packet queue\nMaximum number of packets in queue\nReturns memory usage statistics.\nCreates a new connection buffers instance with default …\nCreates new pooled connection buffers with default …\nUnused capacity (overhead)\nPacket queue\nReturns the total bytes currently in the packet queue.\nCurrent bytes in packet queue\nBytes currently in packet queue\nAllocated capacity of packet queue\nReturns the number of packets in the queue.\nCurrent packets in queue\nPeriodic maintenance: shrink oversized buffers if idle.\nOptional reference to buffer pool (None after release)\nQueues a packet for later processing.\nRead buffer\nBytes allocated for read buffer\nRead buffer diagnostics (if allocated)\nExplicitly releases buffers and performs aggressive …\nResets buffers <strong>without</strong> zeroing memory.\nBytes allocated for all stream buffers\nNumber of stream buffers\nStream buffers\nTotal bytes allocated across all buffers\nTotal bytes actually containing data\nTotal bytes allocated but unused (overhead)\nUpdates the last activity timestamp.\nCreates a new connection buffers instance with custom …\nCreates new pooled connection buffers with custom …\nWrite buffer\nBytes allocated for write buffer\nWrite buffer diagnostics (if allocated)\nCircular buffer is empty\nErrors that can occur during buffer operations\nCircular buffer is full\nAttempted to read/write beyond buffer bounds\nContains the error value\nIncrement would exceed buffer size\nWrite would exceed available space\nInvalid data format\nInvalid buffer state\nInvalid string encoding\nI/O error (for compatibility)\nContains the success value\nPosition exceeds buffer length\nResult type alias for buffer operations\nExtension trait for converting Results between different …\nBuffer size exceeds maximum allowed\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConvert to io::Result\nStandard thread-safe buffer pool using Mutex.\nHigh-performance lock-free buffer pool.\nStatistics for fast buffer pool with thread-local caching.\nA buffer borrowed from the fast pool.\nConfiguration for buffer pool behavior.\nStatistics for standard buffer pool.\nA buffer borrowed from the standard pool.\nTotal number of acquire() calls\nTotal number of new buffers allocated\nNumber of buffers currently available in the pool\nNumber of buffers currently available in the global pool\nSize of each buffer in the pool (bytes)\nSize of each buffer in bytes\nNumber of times a buffer was acquired from thread-local …\nConfiguration for buffer pools\nAutomatically returns the buffer to the pool.\nLock-free high-performance buffer pool with thread-local …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum number of buffers to keep in pool\nMaximum number of buffers the pool can hold\nNumber of buffers to pre-allocate at startup\nTotal number of buffers returned\nStandard mutex-based buffer pool\nStatistics tracking for buffer pools.\nNumber of buffers lost when threads exit with cached …\nTotal number of acquire() calls\nTotal number of buffers allocated since pool creation\nTotal number of buffers returned to pool\nConfiguration for buffer pool behavior.\nSize of each buffer in the pool (bytes)\nConfiguration for high-throughput servers.\nMaximum number of buffers to keep in pool\nNumber of buffers to pre-allocate at startup\nConfiguration for network packet processing (MTU-sized).\nConfiguration for embedded systems (low memory).\nHigh-performance lock-free buffer pool.\nLock-free statistics tracking.\nA buffer borrowed from the fast pool.\nLock-free queue wrapper with size tracking.\nDrop guard for thread-local cache to track lost buffers.\nAcquires a buffer from the pool.\nReturns the number of available buffers in global pool.\nReturns the buffer’s capacity.\nClears the global pool.\nImmediately drops the buffer without returning it to the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLeaks the buffer, preventing return to pool.\nCreates a new fast buffer pool.\nReturns pool statistics.\nPre-allocates buffers up to target size.\nStandard thread-safe buffer pool using Mutex.\nA buffer borrowed from the standard pool.\nAcquires a buffer from the pool.\nReturns the number of available buffers in the pool.\nReturns the buffer’s capacity.\nClears all buffers from the pool.\nImmediately drops the buffer without returning it to the …\nReturns the argument unchanged.\nGrows the pool to the specified size.\nCalls <code>U::from(self)</code>.\nLeaks the buffer, preventing return to pool.\nCreates a new buffer pool with the given configuration.\nShrinks the pool to minimum size.\nReturns pool statistics.\nStatistics for fast buffer pool with thread-local caching.\nStatistics for standard buffer pool.\nTotal number of acquire() calls\nTotal number of new buffers allocated\nNumber of buffers currently available in the pool\nNumber of buffers currently available in the global pool\nSize of each buffer in bytes\nReturns the thread-local cache hit rate as a percentage.\nNumber of times a buffer was acquired from thread-local …\nChecks if the leak rate is concerning.\nReturns the pool hit rate as a percentage (0.0-100.0).\nReturns the number of buffers currently in use (acquired …\nReturns the number of buffers currently in use.\nEstimates total leaked memory from dead threads.\nMaximum number of buffers the pool can hold\nReturns the overall pool hit rate (cache + global pool) as …\nTotal number of buffers returned\nNumber of buffers lost when threads exit with cached …\nTotal number of acquire() calls\nTotal number of buffers allocated since pool creation\nTotal number of buffers returned to pool")